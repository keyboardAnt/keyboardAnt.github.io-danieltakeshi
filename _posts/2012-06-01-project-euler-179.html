---
layout: post
title: Project Euler 179
date: 2012-06-01 12:15:43.000000000 -07:00
categories:
- Computer Science
tags:
- Java
- optimization
- Project Euler
status: publish
type: post
published: true
meta:
  _edit_last: '25629085'
  geo_public: '0'
author:
  login: seitad
  email: takeshidanny@gmail.com
  display_name: Daniel Seita
  first_name: ''
  last_name: ''
excerpt: !ruby/object:Hpricot::Doc
  options: {}
---
<p><a title="Project Euler" href="http://projecteuler.net">Project Euler</a> is an interesting website that offers about 400 different mathematics and computer programming questions. They range from easy (finding the sum of some set of big numbers) to impossible (navigating through Rudin-Shapiro sequences). Just recently, I solved the 179th question with the help of some Java code. While my program gave me the correct answer, the execution time on my Macbook Pro laptop was 80 seconds -- and there is an informal "60 seconds" rule that implies that code should be able to solve a problem in less than 60 seconds. So I wanted to determine in what ways I could optimize my code.</p>
<p>Here was the question: Find the number of integers 1 &lt; n &lt; 10^7, for which n and n + 1 have the same number of positive divisors. For example, 14 has the positive divisors 1, 2, 7, 14 while 15 has 1, 3, 5, 15.</p>
<p>This wasn't too bad for me. I already had a method that could compute the sum of the divisors of a number based on problem 23, so I revised it to add up the <em>number</em> of divisors, rather than the sum. Then I just iterated through each number from 1 to 10 million. Here was the first version of my code:</p>
<p>[sourcecode language="java"]<br />
public class ProjectEuler179 {<br />
    public static void main(String[] args) {<br />
        long startTime = System.currentTimeMillis();<br />
        int result = 0;<br />
        int prevDivisors = 2;<br />
        for (int i = 3; i &lt;= 10000000; i++) {<br />
            int currentDivisors = numberOfDivisors(i);<br />
            if (currentDivisors == prevDivisors) {<br />
                result++;<br />
            }<br />
            prevDivisors = currentDivisors;<br />
        }<br />
        System.out.println(&quot;The number of integers is: &quot; + result + &quot;.&quot;);<br />
        long endTime = System.currentTimeMillis();<br />
        System.out.println(&quot;Execution time: &quot; + (endTime - startTime) + &quot; ms.&quot;);<br />
    }</p>
<p>    public static int numberOfDivisors(int x) {<br />
        int numOfDivisors = 2;<br />
        for (int k = 2; k &lt;= Math.sqrt(x); k++) {<br />
            if (x % k == 0) {<br />
                if (k != Math.sqrt(x)) {<br />
                    numOfDivisors += 2;<br />
                } else {<br />
                    numOfDivisors += 1;<br />
                }<br />
            }<br />
        }<br />
        return numOfDivisors;<br />
    }<br />
}<br />
[/sourcecode]</p>
<p>I'm not going to say what the answer was, but as mentioned before, the execution time (endTime - startTime) was about 80 seconds. Looking at the code, the limiting factor is the 10 million calls I make to the method numOfDivisors(). So how can I improve this? In other words, how can I avoid making all those calls to my static method here?</p>
<p>To start, I initialized an array of 10,000,001 elements, called divs, where divs[x] refers to the number of divisors of x. Then, I used two nested for loops to make sure that each entry of divs[x] <em>did</em> hold the number of divisors of x. The outer for loop went from int i = 1 to 10,000,000, and the inner for loop went as far from int j = 1 to as large a number such that i*j &lt;= x. This implies that all divisors for a number are counted! For instance, if we had the number 2, which has the divisors of 1 and 2, then the entry divs[2] should be incremented twice -- which it is, because of i=1 and j=2 first, then i=2, j=1 second.</p>
<p>Here, I avoid all the testing of "is a number is a factor of another number?", as I do in my old code, because if I consider i*j = n, then I know that n has at least those two factors!</p>
<p>The updated code is as follows:</p>
<p>[sourcecode language="java"]<br />
public class ProjectEuler179 {<br />
    public static void main(String[] args) {<br />
        long startTime = System.currentTimeMillis();<br />
        int result = 0;<br />
        int[] divs = divisors(10000000);<br />
        for (int i = 2; i &lt; 10000000; i++) {<br />
            if (divs[i] == divs[i+1]) {<br />
                result++;<br />
            }<br />
	}<br />
        System.out.println(result);<br />
        long endTime = System.currentTimeMillis();<br />
        System.out.println(&quot;Execution time: &quot; + (endTime - startTime) + &quot; ms.&quot;);<br />
    }</p>
<p>    public static int[] divisors(int x) {<br />
        int[] divs = new int[x + 1];<br />
        for (int i = 1; i &lt;= x; i++) {<br />
            for (int j = 1; i * j &lt;= x; j++) {<br />
                divs[i*j]++;<br />
            }<br />
        }<br />
        return divs;<br />
    }<br />
}<br />
[/sourcecode]</p>
<p>It gave me the right answer. And the runtime was an amazingly quick 1.9 seconds -- much, much better! I don't claim full credit for this second code, as I read the discussion forum for that problem after I solved it the first time, but it's still nice to know how to optimize a program.</p>
